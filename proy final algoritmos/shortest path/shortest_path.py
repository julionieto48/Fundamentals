# -*- coding: utf-8 -*-
"""Shortest path

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13b1nFRp4W_dT-Lzo3obUyqOqoeuF0dLP
"""

class Grafo:
  def __init__(self,numNodos, vertices, weight = False):
    self.numNodos = numNodos
    self.data = [[] for _ in range(numNodos)]
    self.weight = weight
    for nodo1, nodo2 in vertices:
       
      self.data[nodo1].append(nodo2)
      
      
  
  def __repr__(self):
    return "\n".join(["{}:{}".format(nodo,vecinos) for nodo, vecinos in  enumerate(self.data)])

  def __str__(self):
    return self.__repr__()
    


num_nodos  = 11
vertices = []


for i in range(num_nodos ):
  for j in range(num_nodos):
    if i !=j :
      tupla = (i,j)
      vertices.append(tupla)

print(vertices,len(vertices))

colombia = Grafo(num_nodos,vertices)
colombia.__str__
len(colombia.data)

class Grafo:
  def __init__(self,numNodos, vertices, weight = False):
    self.numNodos = numNodos
    self.weight = weight

    self.data = [[] for _ in range(numNodos)]
    self.weight = [[] for _ in range(numNodos)]

    for vertice in vertices:
      if self.weight:
        nodo1 ,nodo2 , weight = vertice
        self.data[nodo1].append(nodo2)
        self.weight[nodo1].append(weight)
      else:
        nodo1 ,nodo2  = vertice
        self.data[nodo1].append(nodo2)
        
       
      
      
  
  def __repr__(self):
    r = ""
    if self.weight:
      for i ,(nodes,weights) in enumerate(zip(self.data,self.weight)):
        r += "{}:{} \n".format(i, list(zip(nodes,weights)))
    else:
      for i , nodes in enumerate(self.data):
        r += "{}:{} \n".format(i,nodes)
    return r

    

  
    


num_nodos  = 11
vertices = []
distancias = [419,177,340,424,216,374,187,432,318,308,419,242,97,323,358,293,246,119,171,361,177,242,172,335,207,284,67,272,176,271,
              340,97,172,251,261,212,157,103,77,267,424,323,335,251,220,51,273,214,182,138,216,358,207,261,220,176,146,310,195,93,
              374,293,284,212,51,176,221,212,138,106,187,246,67,157,273,146,221,245,133,204,432,119,272,103,214,310,212,245,119,284,
              318,171,176,77,182,195,138,133,119,191,309,361,271,267,138,93,106,204,284,191]


for i in range(num_nodos ):
  for j in range(num_nodos):
    if i !=j :
      peso = distancias[0]
      tupla = (i,j,peso)
      vertices.append(tupla)
      distancias.pop(0)

#print(vertices,len(vertices))

colombia = Grafo(num_nodos,vertices, weight = True)
colombia

import time


def sssp(graph, source , target):
  start_time = time.time()
  visitado = [0] * len(graph.data)              # iniciar como no visitados
  distancia = [float('inf')] * len(graph.data)  # predeterminar las distancias en infinito
  queue = [] #fifo

  padre = [None] * len(graph.data)              # la funcion de un nodo padre es que cada que se asigna al queue se sabe cual nodo era el de valor minimo

  distancia[source] = 0
  queue.append(source) 
  inx = 0                                       # siguiente elemento para hacer deque   

  while inx < len(queue) and visitado[target] == 0 :      # objetivo no visitado
    actual = queue[inx]
    visitado[target] = 1
    inx += 1 

    # actualizar distancias vecinas
    actualizarDistancias(graph, actual,distancia , padre)

    # encontrar/ seleccionar el nodo no visitado con la distancia mas corta
    sig_nodo = seleccionarSiguienteNodo(distancia,visitado)

    if sig_nodo:
      queue.append(sig_nodo)

 
  end_time = time.time()
  print("tiempo de ejecucion: " , end_time - start_time)
  return distancia[target] , padre






def actualizarDistancias(graph, actual,distancia , parent=None):
  vecinos = graph.data[actual]
  pesos  = graph.weight[actual]

  for i , nodo in enumerate(vecinos): # ej 0 : [1,2,3,4,5...10]
    peso = pesos[i]                   # obtengo el peso y el vertice al que esta conectado el nodo "actual"

    if distancia[actual] + peso < distancia[nodo] :  # distancia[nodo] puede ser infinita o ya seteada por haber sido visitada
      distancia[nodo] = distancia[actual] + peso     # se actualiza 

      if parent:
        parent[nodo] = actual                       # el nodo actual se vuelve le padre ... de la distancia actualizada





def seleccionarSiguienteNodo(distancia,visitado):
  distanciaMinima = float('inf')
  nodoMin =  None #el nodo con menor distancia

  for nodo in range(len(distancia)):
    if visitado[nodo] == 0  and distancia[nodo] < distanciaMinima:
      nodoMin = nodo
      distanciaMinima = distancia[nodo]
  return nodoMin

import matplotlib.pyplot as plt
import networkx as nx

ciudades = ["Quibdo" ,"Pereira","Manizales","Medellin","Honda","Caucasia","Monteria","Sincelejo","Santa Marta","Valledupar","Riohacha"]
distancias = [419,177,340,424,216,374,187,432,318,308,419,242,97,323,358,293,246,119,171,361,177,242,172,335,207,284,67,272,176,271,
              340,97,172,251,261,212,157,103,77,267,424,323,335,251,220,51,273,214,182,138,216,358,207,261,220,176,146,310,195,93,
              374,293,284,212,51,176,221,212,138,106,187,246,67,157,273,146,221,245,133,204,432,119,272,103,214,310,212,245,119,284,
              318,171,176,77,182,195,138,133,119,191,309,361,271,267,138,93,106,204,284,191]


G = nx.Graph()



for i in range(len(ciudades) ):
  for j in range(len(ciudades)):
    if i !=j :
      
      G.add_edge(ciudades[i],ciudades[j] , weight=distancias[0])
      distancias.pop(0)
      

elarge = [(u, v) for (u, v, d) in G.edges(data=True) if d["weight"] > 0.5]
esmall = [(u, v) for (u, v, d) in G.edges(data=True) if d["weight"] <= 0.5]

pos = nx.spring_layout(G, seed=7)  # positions for all nodes - seed for reproducibility

# nodes
nx.draw_networkx_nodes(G, pos, node_size=700)

# edges
nx.draw_networkx_edges(G, pos, edgelist=elarge, width=0.5)
nx.draw_networkx_edges(
    G, pos, edgelist=esmall, width=4, alpha=0.2, edge_color="b", style="dashed"
)

# node labels
nx.draw_networkx_labels(G, pos, font_size=7, font_family="sans-serif")
# edge weight labels
edge_labels = nx.get_edge_attributes(G, "weight")
nx.draw_networkx_edge_labels(G, pos, edge_labels)

ax = plt.gca()
ax.margins(0.0004)
plt.axis("off")
plt.tight_layout()
plt.show()


# https://networkx.org/documentation/stable/auto_examples/drawing/plot_weighted_graph.html

dist,camino = sssp(colombia, 0 , 8)
print("la longitud mas corta es: " ,dist, "km"  )
print("con la ruta mas corta: " ,camino )

[x for x in range(10)]
[x*x for x in range(10)]
a = [[] for _ in range(10)]
print(a)

for i in enumerate([5,3,4,1]):
  print(i)

import sys

class Graph():
    
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0 for column in range(vertices)]
                    for row in range(vertices)]
 
    def printSolution(self, dist):
        print("Vertice \t Distancia")
        for node in range(self.V):
            print(node, "\t", dist[node])
 
    # cual es el vertice con el min valor
    def minDistance(self, dist, sptSet):
 
        # Initialize minimum distance for next node
        min = sys.maxsize
 
        # Buscar el vértice no más cercano que no esté en el árbol de ruta más corta
        for u in range(self.V):
            if dist[u] < min and sptSet[u] == False:
                min = dist[u]
                min_index = u
 
        return min_index
 
    
    def dijkstra(self, src):
        start_time = time.time()
        dist = [sys.maxsize] * self.V
        dist[src] = 0
        sptSet = [False] * self.V
 
        for cout in range(self.V):
 
           

            # Elije el vértice de distancia mínima desde
            # el conjunto de vértices aún no procesados.
            # x siempre es igual a src en la primera iteración
            x = self.minDistance(dist, sptSet)
 
            # Put the minimum distance vertex in the
            # shortest path tree
            sptSet[x] = True
 
            # Actualizar el valor dist de los vértices adyacentes
            # del vértice seleccionado solo si en el actual
            # la distancia es mayor que la nueva distancia y
            # el vértice no está en el árbol del camino más corto
            for y in range(self.V):
                if self.graph[x][y] > 0 and sptSet[y] == False and \
                dist[y] > dist[x] + self.graph[x][y]:
                        dist[y] = dist[x] + self.graph[x][y]
 
        self.printSolution(dist)
        end_time = time.time()
        print("tiempo de ejecucion: " , end_time - start_time)
 
# Driver program
g = Graph(11)
g.graph = [[ 0, 419, 177, 340, 424, 216, 374, 187, 432, 318, 308 ],
           [ 419, 0, 242, 97, 323, 358, 293, 246, 119, 171, 361  ],
           [ 177, 242, 0, 172, 335, 207, 284, 67, 272, 176, 271  ],
           [ 340, 97, 172, 0, 251, 261, 212, 157, 103, 77, 267   ],
           [ 432, 119, 272, 103, 214, 310, 212, 245, 0, 119,	284 ],
           [ 424, 323, 335, 251, 0, 220, 51, 273, 214, 182, 138  ],
           [ 308, 361, 271, 267, 138, 93, 106, 204, 284, 191,0   ], 
           [ 216, 358, 207, 261, 220, 0,	176, 146, 310, 195,	93  ],
           [ 374, 293, 284, 212, 51, 176, 0, 221, 212, 138, 106  ],
           [ 187, 246, 67 , 157, 273, 146, 221, 0, 245, 133, 204 ],
           [ 318, 171, 176, 77, 182, 195, 138, 133, 119, 0,	191 ],
        ];
 
g.dijkstra(0);

